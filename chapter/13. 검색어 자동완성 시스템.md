# 1단계 : 문제 이해 및 설계 범위 확정

- 사용자가 입력하는 단어는 자동완성될 검색어의 첫부분
- 5개의 자동완성 검색어가 표시
- 질의 빈도에 따라 인기 순위를 기준
- 맞춤법 검사이나 자동수정은 지원 X
- 시간이 된다면 다국어 지원
- 대문자 X, 특수 문자 처리 X
- 일간 능동 사용자 기준으로 천만 명

요구사항

- 빠른 응답 속도 : 시스템 응답속도 100밀리초
- 연관성
- 정렬 : 인기도 등의 순위 모델에 의해 정렬
- 규모 확장성 : 시스템은 많은 트래픽을 감당할 수 있도록 확장 가능해야 한다.
- 고가용성

### **개략적 규모 추정**

- 일간능동 사용자는 천만명
- 한 사용자는 매일 10건의 검색을 수행한다고 가정
- 질의할 때마다 평균적으로 20바이트의 데이터를 입력한다고 가정
    - 문자 인코딩 방법으로는 ASCII → 1문자 = 1바이트
    - 질의문은 평균적으로 4개의 단어로 이루어진다고 가정 , 각 단어는 평균적으로 5글자로 구성되었다고 가정
    - 질의당 평균 20바이트
- 검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다.
    - search?q=d
    - search?q=di
    - search?q=din
    - search?q=dinn
    - search?q=dinne
    - search?q=dinner
- 대략 초당 24,000건의 질의가 발생할 것
    - 10,000,000 사용자 * 10 질의 / 일 * 20 자 / 24시간 / 3600 초
- 최대 QPS = QPS * 2 = 대략 48,000
- 질의 20%는 신규 검색어 → 대략 0.4GB

# 2단계 개략적 설계안 제시 및 동의 구하기

시스템은 두 부분으로 나뉘다.

- 데이터 수집 서비스 : 사용자가 입력한 질의를 실시간으로 수집하는 시스템.
    - 데이터가 많은 애플리케이션에 실시간 시스템은 그다지 바람직하지 않지만 설계안을 만드는 출발점으로는 괜찮을 것이다.
- 질의 서비스 : 주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는 서비스이다.

 

### 데이터 수집 서비스

빈도 테이블 = 질의문 + 사용빈도

### 질의 서비스

- query : 질의문을 저장하는 필드
- frequency : 질의문이 사용된 빈도를 저장하는 필드

```sql
SELECT * FROM frequency_table
WHERE query Like 'prefix%'
ORDER BY frequency DESC
LIMIT 5
```

데이터가 많아지면 데이터베이스가 병목이 될 수 있다.

# 3단계 상세 설계

- 트라이 자료 구조
- 데이터 수집 서비스
- 질의 서비스
- 규모 확장이 가능한 저장소
- 트라이 연산

### (1) 트라이 자료구조

관계형 디비를 이용해 가장 인기 있었던 5개의 질의문을 골라내는 방안은 효율적이지 않다. 

이 문제는 트라이(접투어 트리) 라고 한다.

→ 트라이가 시스템의 핵심적 부분이 될 것 이므로 중요!

트라이는 문자열들을 간략하게 저장할 수 있는 자료구조이다.

문자열을 꺼내는 연산에 초점을 맞추어 설계된 자료구조임을 미루어 짐작할 수 있다.

![스크린샷 2025-09-14 오후 11.11.11.png](attachment:13bae4ba-8807-44f3-b4ef-ed83766ae2e8:스크린샷_2025-09-14_오후_11.11.11.png)

- 트라이는 트리 형태의 자료구조
- 이 트리의 루트 노드는 빈 문자열을 나타낸다.
- 각 노드는 글자 하나를 저장하며 26개의 자식 노드를 가질 수 있다.
- 각 트리노드는 하나의 단어, 또는 접두어 문자열을 나타낸다.

### 접두어 최대 길이 제한

검색어의 최대 길이를 제한할 수 있다면 접두어 노드를 찾는 단계의 시간복잡도가 O(p) → O(작은 상숫값) =  O(1)

### 노드에 인기 검색어 캐시

각 노드에 k 개의 인기 검색어를 저장해 두면 전체 트라이를 검색하는 일을 방지할 수 있다.

- 장 : 검색어를 질의하는 시간 복잡도를 엄청나게 낮출 수 있다.
- 단 : 각 노드에 질의어를 저장할 공간이 많이 필요하게 된다. → 빠른 응답속도가 아주 중요할 때는 이 정도 저장공간을 희생할 만한 가치가 있다.

둘 다 O(1)로 변경된다.

### (2) 데이터 수집 서비스

- 매일 수천만 건의 질의가 입력될 텐데 그때마다 트라이를 갱신하면 질의 서비스는 심각하게 느려질 것이다.
- 일단 트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것이다. 그러니 트라이는 자주 갱신할 필요 없다.

규모 확장이 쉬운 데이터 수집 서비스를 만들려면 데이터가 어디서 오고 어떻게 이용되는지를 살펴야 한다.

트위터 같은 실시간 애플리케이션이라면 제안되는 검색어를 항상 신선하게 유지할 필요가 있을 수 있겠지만 구글 검색 같은 애플리케이션이라면 그렇게 자주 바꿔줄 이유는 없을 것이다.

- 데이터 분석 서비스 로그
검색창에 입력된 질의에 관한 원본 데이터가 보관, 새로운 데이터가 추가될 뿐 수정은 이루어지지 않으며 로그 데이터에는 인덱스를 걸지 않는다.
- 로그 취합 서버
양이 엄청나고 데이터 형식도 제각각인 경우가 많다. 따라서 이 데이터를 잘 취합하여 우리 시스템이 쉽게 소비할 수 있도록 해야 한다.
취합 방식은 우리 서비스의 용례에 따라 달라질 수 있다.
- 작업 서버
비동기적 작업을 실행하는 서버 집합으로, 트라이 자료구조를 만들고 트라이 데이터 베이스에 저장하는 역할
- 트라이 캐시
분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 성능을 높이는 구실을 한다.
- 트라이 데이터베이스
지속성 저장소로, 사용할 수 있는 선택지는 두 가지가 있다.
    - 문서 저장소 : 새 트라이를 매주 만들 것이므로, 주기적으로 트라이를 직렬화하여 데이터베이스에 저장할 수 있다. 몽고디비 추천
    - 키 값 저장소 : 로직을 적용하여 해시 테이블 형태로 변환 가능하다.
    - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
    - 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환

### (3) 질의 서비스

1. 검색 질의가 로드밸런서로 전송된다.
2. 로드 밸런서는 해당 질의를 API 서버로 보낸다.
3. API 서버는 트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성한다.
4. 데이터가 트라이 캐시에 없는 경우에는 데이터를 디비에서 가져와 캐시에 채운다. 그래야 다음에 같은 접두어에 대한 질의가 오면 캐시에 보관된 데이터를 사용해 처리할 수 있다. 캐시 미스는 캐시 서버의 메모리가 부족하거나 캐시 서버에 장애가 있어도 발생할 수 있다.

- AJAX 요청 : 웹 애플리케이션의 경우 브라우저는 보통 AJAX 요청을 보내어 자동완성된 검색어 목록을 가져온다. 장점은 요청을 보내고 받기 위해 페이지를 새로고침할 필요가 없다는 것이다.
- 브라우저 캐싱 : 대부분의 경우 자동완성 검색어 제안 결과는 짧은 시간 안에 자주 바뀌지 않기 때문에 넣어두면 후속 질의의 결과는 해당 캐시에서 바로 가져갈 수 있다. 구글엔진이 이에 해당한다.
- 데이터샘플링 : 대규모 시스템의 경우, 모든 질의 결과로 로깅하도록 해 놓으면 CPU 자원과 저장공간을 엄청나게 소진하게 된다.이럴 때 유용하다. 즉, N개의 요청 가운데 1개만 로깅하도록 하는 것이다.

### (4) 트라이 연산

트라이는 검색어 자동완성 시스템의 핵심 컴포넌트다. 

- 트라이 생성 : 작업 서버가 담당하며, 데이터 분석 서비스의 로그나 데이터베이스로부터 취합된 데이터를 이용한다.
- 트라이 갱신
    - 매주 한 번 갱신하는 방법 : 새로운 트라이를 만든 다음에 기존 트라이를 대체한다.
    - 트라이의 각 노드를 개별적으로 갱신하는 방법 ← 성능이 좋지 않다. 작을 경우에는 고려해봄직한 방법이다.
- 검색어 삭제 : 위험한 질의어를 자동완성 결과에서 제거해야 한다. 트라이 앞에 필터 계층을 두고 부적절한 질의어가 반환되지 않도록 하는 것이다.
