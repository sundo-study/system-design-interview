# 0. 유튜브에 대한 통계

- 월간 능동 사용자 수: 20억
- 매일 재생되는 비디오 수: 50억
- 미국 성인 가운데 73%가 유튜브 이용
- 5천만 명의 창작자
- 유튜브의 광고 수입은 2019년 기준으로 150억 달러이며, 이는 2018년도 대비 36%가 증가한 수치.
- 모바일 인터넷 트래픽 가운데 37%를 유튜브가 점유
- 약 80개 언어로 이용 가능

# 1. 문제 이해 및 설계 범위 확정

유튜브에서는 단순히 비디오를 보는 것 말고도 많은 일을 할 수 있다. 댓글을 남길 수도 있고, 비디오를 공유하거나 좋아요 버튼을 누를 수도 있고, 플레이리스트에 저장을 할 수도 있고, 채널을 골라 구독할 수도 있다. 하지만 이 모든 기능을 면접 시간동안 설계하는 것은 불가능하기 때문에, 설계 범위를 확정하는 것이 중요하다.

## 예시 요구사항

아래는 면접관과의 질의를 통해 완성될 수 있는 예시 요구사항이다.

1. 빠른 비디오 업로드
2. 원활한 비디오 재생
3. 재생 품질 선택 기능
4. 최대한 낮은 인프라 비용
5. 높은 가용성과 규모 확장성, 그리고 안정성
6. 지원 클라이언트 : 모바일 앱, 웹브라우저, 그리고 스마트 TV등 여러 단말

## 개략적 규모 추정

1. 일간 능동 사용자는 5백만
2. 한 사용자는 하루에 평균 5 개의 비디오를 시청
3. 10% 의 사용자가 하루에 1비디오 업로드
4. 비디오 평균 크기는 300MB
5. 비디오 저장을 위해 매일 새로 요구되는 저장 용량 = 5 백만 x 10% x 300MB = 150TB
6. CDN 비용 추정치
    - 클라우드 CDN 을 통해 비디오를 서비스할 경우 CDN 에서 나가는 데이터의 양에 따라 과금한다.
    - 아마존의 클라우드 프론트를 CDN으로 사용할 경우, 10% 트래픽이 미국에서 발생한다고 가정하면 1GB 당 $0.02 의 요금이 발생한다. 문제를 단순화하기 위해 비디오 스트리밍 비용만 따지도록 하겠다.
    - 따라서 매일 발생하는 요금은 5백만 X 5 비디오 x 0.3GB X 0.02 = 무려 $150,000이다.

# 2. 개략적 설계안

개략적으로 보면 이 시스템은 다음의 세 개 컴포넌트로 구성될 것이다.

<img width="810" height="354" alt="image" src="https://github.com/user-attachments/assets/4faa77e0-1477-44fb-b975-f09ef76f88ae" />


- 단말: 유튜브를 시청할 수 있는 클라이언트.
- CDN: 비디오는 CDN에 저장한다. 재생 버튼을 누르면 CDN 으로부터 스트리밍이 이루어진다.
- API 서버 : 비디오 스트리밍을 제외한 모든 요청은 API 서버가 처리한다.
    - 피드추천, 업로드용 URL 생성, 메타데이터에 대한 DB 로직, 캐시처리, 등등을 수행한다.

## 비디오 업로드 절차

아래 그림은 비디오 업로드의 개략적인 절차다.

<img width="1416" height="1364" alt="image" src="https://github.com/user-attachments/assets/fd86b312-a587-4896-b408-090d8d774a49" />


이 설계안의 컴포넌트 별 역할은 다음과 같다.

- **사용자** : 컴퓨터나 모바일 등의 단말을 통해 유튜브를 시청하는 이용자다.
- **로드밸런서**: 분산된 API 서버 각각으로 고르게 요청을 분산하는 역할을 수행한다.
- **API 서버**: 비디오 스트리밍을 제외한 다른 모든 요청을 처리한다.
- **메타데이터용 DB**: 비디오의 메타데이터, 사용자에 대한 데이터 등을 처리하는 데이터베이스이다.
    - 샤딩과 다중화를 통해 읽기성능 및 가용성, 확장성 요구사항을 달성해야 한다.
- **메타데이터용 캐시**: 성능을 높이기 위해 비디오 메타데이터와 사용자에 대한 데이터를 캐싱한다.
- **원본 저장소**: 원본 비디오 데이터를 이진 파일 형식(BLOB)으로 저장할 저장소이다.
- **트랜스코딩 서버**: 비디오 트랜스코딩은 비디오 인코딩이라고 부르는 절차로, 비디오의 포맷을 변환하는 절차이다. 트랜스코딩 서버는 비디오 인코딩을 수행한다.
    - 트랜스 코딩은 단말이나 대역폭에 따라 비디오의 포맷에 대한 요구가 달라지기 때문에 필요하다.
- **트랜스코딩 비디오 저장소**: 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소이다.
    - 요구에 맞춰 그때그때 변환하는 것보다 변환된 데이터를 저장하는 것이 효율적일 것이다.
- **CDN**: 비디오를 캐시하는 역할을 담당한다. 사용자가 재생 버튼을 누르면 비디오 스트리밍은 CDN을 통해 이루어진다.
- **트랜스코딩 completion queue**: 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐다.

## 비디오 업로드 처리

유튜브에 비디오가 업로드 되면 다음 두 가지 절차가 동시적으로 수행된다.

1. 비디오 파일 업로드
2. 비디오 메타데이터 갱신(비디오 url, size, 해상도, 포맷 및 유저정보가 포함된다)

### 비디오 파일 업로드 처리 과정

1. 원본 비디오 업로드
    - 비디오를 원본 저장소에 업로드
2. 트랜스코딩 시작
    - 트랜스코딩 서버가 원본 저장소에서 비디오를 가져와 트랜스코딩 시작
3. 트랜스코딩 완료 후 병렬 처리
    1. 완료된 비디오를 트랜스코딩 비디오 저장소에 업로드
    2. 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣는다.
    - 3b.1. 완료 핸들러가 큐에서 이벤트 데이터 수신
    - 3b.2. 완료 핸들러가 메타데이터 데이터베이스와 캐시 업데이트
4. 업로드 완료 알림
    - API 서버가 단말에게 비디오 업로드 완료 및 스트리밍 준비 완료 알림

### 메타데이터 갱신 과정

단말은 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버에 보낸다.

- 메타데이터에는 비디오의 url, size, 해상도, 포맷 및 유저정보가 포함된다.
- 캐시 서버에 해당 데이터를 DB로부터 읽어들일 때 캐시해두는 것이 좋을 것이다.

## 비디오 스트리밍 절차

우리는 먼저 스트리밍 프로토콜이라는 중요한 개념을 알아두어야 한다. 스트리밍 프로토콜은 비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신방법이다.

이 프로토콜의 동작 원리를 정확하게 이해하거나 그 이름들을 외울 필요는 없다. 구현 디테일에 해당하는 부분일 뿐인데다, 확실히 이해하려면 관련 분야의 도메인 지식을 알아야 하기 때문이다.

기억해야 하는 것은 프로토콜마다 지원하는 비디오 인코딩이 다르고 플레이어도 다르다는 것이다. 따라서 비디
오 스트리밍 서비스를 설계할 때는 서비스의 용례에 맞는 프로토콜을 잘 골라야 한다.

비디오는 CDN 에서 바로 스트리밍된다. 사용자의 단말에 가장 가까운 CDN Edge server가 비디오 전송을 담당할 것이다. 따라서 전송지연은 아주 낮을 것이다.

# 3. 상세 설계

전체 시스템을 크게 두 부분, 비디오 업로드 부분과 스트리밍 부분으로 나누어서 살펴봤다. 두 부분에 대해서 조금 더 상세하게 알아보고, 오류 처리 메커니즘도 알아보자.

## 비디오 트랜스코딩

비디오를 녹화하면 단말은 해당 비디오를 특정 포맷으로 저장한다. 이 비디오가 다른 단말에서도 순조롭게 재생되려면 다른 단말과 호환되는 비트레이트(bit-rate)와 포맷으로 저장되어야 한다.

비트레이트는 비디오를 구성하는 비트가 얼마나 빨리 처리되어야 하는지를 나타내는 단위이다. 비트레이트가 높을 수록 보통 고화질의 비디오다. 비트레이트가 높은 비디오 스트림을 정상 처리하기 위해서는

1. 높은 성능의 컴퓨팅 파워가 필요하고,
2. 인터넷 대역폭도 크고, 회선 속도도 빨라야 한다.

비디오 트랜스코딩은 다음과 같은 이유로 특히 중요하다.

1. 가공되지 않은 원본 비디오는 저장 공간을 많이 차지한다. 
2. 상당수의 단말과 브라우저는 특징 종류의 비디오 포맷만 지원한다. 이는 호환성 문제를 일으킬 수 있다.
3. 네트워크 대역폭이 충분하지 않은 사용자에게는 저화질 비디오를, 대역폭이 충분한 사용자에게는 고화질 비디오를 보내는 것이 바람직하다.
4. 네트워크 상황에 맞춰서 비디오화질을 자동 혹은 수동으로 변경 가능해야 한다.

인코딩 포맷은 다음 두 부분으로 구성된다.

1. 컨테이너: 비디오 파일, 오디오, 메타 데이터를 담는 바구니이다. 컨테이너 포맷은 .avi, .mov, .mp4 같은 파일 확장자를 보면 알 수 있다.
2. 코덱(codec): 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘이다.

## 유향 비순환 그래프(DAG) 모델

비디오를 트랜스코딩하는 것은 컴퓨팅 자원을 많이 소모할 뿐 아니라 시간도 많이 드는 작업이다. 게다가 콘텐츠 창작자는 각자 자기만의 비디오 프로세싱 요구사항을 갖고 있다.

1. 어떤 사람은 비디오 위에 워터마크(watermark)를 표시하고 싶어 할 것이고,
2. 어떤 사람은 섬네일 이미지를 자기가 손수 만들어 쓰고 싶어 할 것이고,
3. 어떤 사람은 고화질 비디오를 선호하는 반면 또 다른 어떤 이는 저화질 비디오도 충분하다고 생각할 것이다.

이처럼 각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하는 한편 처리 과정의 병렬성을 높여야 하고, 또 적절한 수준의 추상화를 도입하여 클라이언트 프로그래머로 하여금 실행할 작업(task)을 손수 정의할 수 있도록 해야 한다.

페이스북의 스트리밍 비디오 엔진은 유향 비순환 그래프 프로그래밍 모델을 도입해서 작업을 단계별로 배열할 수 있도록 하여 해당 작업들이 순차적으로 또는 병렬적으로 실행될 수 있도록 한다.

<img width="868" height="511" alt="image" src="https://github.com/user-attachments/assets/70e53f7c-23fc-4aba-b76b-62ab814520fd" />


원본 비디오 입력은 비디오, 오디오, 메타데이터의 세 부분으로 나뉘어 처리된다. 비디오 부분에 적용되는 작업은 다음과 같다.

1. inspection: 좋은 품질의 비디오인지, 손상은 없는지 확인하는 작업이다.
2. 비디오 인코딩: 비디오를 다양한 해상도, 코덱, 비트레이트조합으로 인코딩하는 작업이다.
3. thumbnail: 사용자가 업로드한 이미지나 비디오에서 자동 추출된 이미지로 섬네일을 만드는 작업이다.
4. watermark: 비디오에 대한 식별정보를 이미지 위에 오버레이(overlay) 형태로 띄워 표시하는 작업이다.

## 비디오 트랜스코딩 아키텍처

본 설계안에서는 클라우드 서비스를 활용한 비디오 트랜스코딩 아키텍처를 다음과 같이 정의한다.

<img width="870" height="212" alt="image" src="https://github.com/user-attachments/assets/d6e447cc-d939-4c94-ac78-547376b81dbb" />


이 아키텍처는 다섯 개의 주요 컴포넌트로 구성된다. 전처리기(preprocessor), DAG 스케줄러, 자원 관리자 (resource manager), 작업 실행 서버 (resource worker), 임시 저장소(temporary storage)가 그것이다.

### 전처리기

전처리기가 하는 작업은 다음과 같다.

1. 비디오 분할: 비디오 스트림을 GOP(Group of Pictures)라고 불리는 단위로 쪼갠다. GOP 는 특정 순서로 배열된 프레임(frame) 그룹이다. 하나의 GOP는 독립 재생이 가능하다.
    
    > **GOP (Group Of Pictures)**
    > 
    > 
    > MPEG 표준 비디오 압축 기술에서 사용되는 프레임(이미지)의 집합을 의미합니다. 쉽게 말해서 여러 장의 이미지를 하나로 그룹화 해서 압축하는 방식이라고 생각하시면 됩니다.
    > 
2. DAG 생성 : 클라이언트 프로그래머가 작성한 설정 파일에 맞춰 DAG를 만들어낸다.
3. 데이터 캐시: 전처리기는 분할된 비디오의 캐시이기도 하다. 안정성을 높이기 위해 전처리기는 GOP와 메타데이터를 임시 저장소에 보관한다. 만약 도중에 실패하면 임시저장소로부터 중간 지점을 복구한다.

### DAG 스케줄러

DAG 스케줄러는 DAG 그래프를 몇 개 단계로 분할한 다음에 그 각각을 자원 관리자의 TaskQueue에 넣는다.

<img width="851" height="434" alt="image" src="https://github.com/user-attachments/assets/33f670dd-c574-4930-9f80-7062354ab157" />


위의 경우에는 하나의 DAG 그래프를 2개의 작업 단계로 분리하였다. 해당 구조에 맞춰 병렬성을 적용 가능해 보인다. 가령 1단계에 동시 수행 가능한 작업들을 동시적으로 다른 프로세서에서 실행시키고, 2단계도 마찬가지로 적용하면 효율적일 것이다.

### 자원 관리자

자원 관리자(resource manager)는 자원 배분을 효과적으로 수행하는 역할을 담당한다. 다음과 같이 세 개의 큐와 작업 스케줄러로 구성할 수 있다.

- 작업 큐(task queue): 실행할 작업이 보관되어 있는 우선순위 큐(priority queue)이다.
- 작업 서버 큐(worker queue): 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐다.
- 실행 큐(running queue): 현재 실행 중인 작업 및 작업 서버 정보가 보관되어 있는 큐다.
- 작업 스케줄러: 최적의 작업/서버 조합을 골라, 해당 작업 서버가 작업을 수행하도록 지시한다.

<img width="868" height="273" alt="image" src="https://github.com/user-attachments/assets/25408fee-cb2d-4990-ab32-ce8e343fd6f2" />


1. 작업 관리자는 작업 큐에서 가장 높은 우선순위의 작업을 꺼낸다.
2. 작업 관리자는 해당 작업을 실행하기 적합한 작업 서버를 고른다.
3. 작업 스케줄러는 해당 작업 서버에게 작업 실행을 지시한다.
4. 작업 스케줄러는 해당 작업이 어떤 서버에게 할당 되었는 지에 관한 정보를실행 큐에 넣는다.
5. 작업 스케줄러는 작업이 완료되면 해당 작업을 실행 큐에서 제거한다.

### 작업 서버

작업 서버는 DAG 에 정의된 작업을 수행한다. 실행 큐에 자신 서버에 대한 작업이 있다면 그걸 꺼내서 수행한다.

### 임시 저장소

임시 저장소 구현에는 여러 저장소 시스템을 활용할 수 있다. 어떤 시스템을 선택할 것이냐는 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등에 따라 달라진다. 예를 들어 메타데이터는 작업 서버가 빈번히 참조하는 정보이고 그 크기도 작은 것이 보통이다. 따라서 메모리에 캐시해 두면 좋을 것이다. 그러나 비디오 / 오디오 데이터는 BLOB 저장소에 두는 것이 바람직하다. 임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제한다.

### 인코딩된 비디오

인코딩된 비디오는 인코딩 파이프라인의 최종 결과물이다. 

- XXX_720p.mp4와 같은 이름을 가지고, 이름을 통해 인코딩 유형을 확인 가능하도록 한다.

## 시스템 최적화

### 비디오 병렬 업로드

<img width="718" height="97" alt="image" src="https://github.com/user-attachments/assets/6b284e8d-08f0-4d20-82b9-1ff6123bed84" />


비디오 전부를 한 번의 업로드로 올리는 것은 비효율적이다. 하나의 비디오는 그림과 같이 작은 GOP 들로 분할할 수 있다.

<img width="836" height="144" alt="image" src="https://github.com/user-attachments/assets/5563711a-2add-4890-ba23-1ae01fefcab1" />


이렇게 분할한 GOP 를 병렬적으로 업로드하면 일부가 실패해도 빠르게 업로드를 재개할 수 있다. 비디오를 GOP 경계에 맞춰 분할하는 작업을 단말이 수행하면과 같이 저장소 업로드 속도를 높일 수도 있다.

### 업로드 센터를 사용자 근거리에 지정

업로드 속도를 개선하는 또 다른 방법은 업로드 센터를 여러 곳에 두는 것이다. 미국 거주자는 비디오를 북미 지역 업로드 센터로 보내도록하고 ,중국 사용자는 아시아 업로드 센터로 보내도록 한다. 이를 위해 CDN을 업로드 센터로 사용할 수 있다.

### 모든 절차를 병렬화 하기

낮은 응답지연을 달성하는 것은 어려운 일이다. 이를 위한 또 하나의 방법은, 느슨하게 결합된 시스템을 만들어서 병렬성을 높이는 것이다.

<img width="875" height="326" alt="image" src="https://github.com/user-attachments/assets/7b4a37f4-c8dc-4c74-a6fb-04fb9faf2141" />


비디오를 원본 저장소에서 CDN 으로 옮기는 절차는 그림과 같다. 어떤 단계의 결과물은 이전 단계의 결과물을 입력으로 사용하여 만들어진다는 것을 알 수 있다. 

만약 이 절차를 연결해서 처음부터 끝까지 수행하게 한다면 병렬성을 높이기 힘들다. 모든 절차들이 결합되어 있기 때문이다.

이 시스템의 결합도를 낮추기 위해 아래 그림과 같이 메세지큐를 도입할 수 있다.

- 메시지 큐를 도입하기 전에 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다려야 했다.
- 메시지 큐를 도입한 뒤에 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 더 이상 기다릴 필요가 없다. 메시지 큐에 보관된 이벤트 각각을 인코딩 모듈은 병렬적으로 처리할 수 있다.

<img width="899" height="482" alt="image" src="https://github.com/user-attachments/assets/b0b7eb2f-ec17-4a86-9ce9-4a5a5a0d074e" />


### 업로드 pre-signed-url 사용

허가받은(authorized) 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록 하기 위해 그림과 같이 pre-signed 업로드 URL 을 이용할 수 있다.

<img width="873" height="366" alt="image" src="https://github.com/user-attachments/assets/ce4e3c3c-6323-4608-a23a-e1688f1ce097" />


이를 위해서 업로드 절차를 아래와 같이 변경해야 한다.

1. 클라이언트는 API서버에 pre-signed-url을 요청을 보낸다.
2. API 서버는 pre-signed-url을 응답한다. 이때, pre-signed-url에 대한 접근 권한이 주어진 상태여야 한다.
    1. API서버는 보유한 키를 통해 원본 스토리지에 제한시간이 설정된 pre-signed-url 요청을 한다.
    2. 응답으로 받은 pre-siged-url을 클라이언트에게 응답한다.
3. 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.

### 컨텐츠 보호

비디오의 저작권을 보고하기 위해 다음 세가지 선택지 가운데 하나를 채택할 수 있다.

1. 디지털 저작권 관리 (DRM: Digital Rights Management) 시스템 도입
    
    > **DRM 작동 원리**
    > 
    > 1. 콘텐츠 Encryption: 콘텐츠 저작권자는 콘텐츠를 유통하기 전에 내용에 암호화 기술 적용
    > 2. 권한 확인 및 라이선스 발급: 사용자가 암호화된 콘텐츠를 사용하려고 요청하면, DRM 시스템은 사용자의 신원을 확인하고 권한이 있는지 검증
    > 3. 사용자에게 권한이 있다고 판단될 경우, 콘텐츠를 복호화할 수 있는 '라이선스 키'를 발급. 이 라이선스에는 콘텐츠 사용 기간, 허용 범위(열람, 인쇄, 복사 등)와 같은 다양한 권한 정보가 포함.
2. AES 암호화(encryption): 비디오를 암호화하고 접근 권한을 설정하는 방식이다. 암호화된 비디오는 재생 시에만 복호화한다. 허락된 사용자만 암호화된 비디오를 시청할 수 있다.
3. 워터마크 (watermark): 비디오 위에 소유자 정보를 포함하는 이미지 오버레이를 올리는 것이다.

### 비용 최적화

CDN은 성능에 있어서 핵심적이지만, 비용이 비싸다. 연구 결과에 따르면, 유튜브의 비디오 스트리밍은 롱테일 (Iong-tail)분포를 따른다. 인기 있는 비디오를 제외하면 거의 보는 사람이 없다고 한다. 이 점이 최적화 포인트다.

1. 인기 비디오만 CDN 을 통해 재생되게 하자.
2. 인기 없는 비디오는 낮은 해상도로만 인코딩 해도 충분할 수 있다. 혹은 인코딩 없이 사용할 수도 있다.
3. 특정 비디오는 특정 지역에서만 인기가 높은 경우도 많다. 이런 비디오는 다른 지역에도 저장할 필요는 없다.
4. 정말 대규모 서비스라면 CDN을 직접 구축하는 것도 생각해 볼만 하다.

## 오류 처리

시스템 오류에는 두 가지 종류가 있다.

1. 회복 가능 오류: 특정 비디오 세그먼트를 트랜스코딩하다 실패했다든가 하는 오류는 회복 가능한 오류에 속한다. 일반적으로 보자면 이런 오류는 몇 번 재시도(retry) 하면 해결된다. 하지만 계속해서 실패하고 복구가 어렵다 판단되면 클라이언트에게 적절한 오류 코드를 반환해야 한다.
2. 회복 불가능 오류: 비디오 포맷이 잘못되었다거나 하는 회복 불가능한 오류가 발견되면 시스템은 해당 비디오에 대한 작업을 즉시 중단하고 클라이언트에게 적절한 오류 코드를 반환해야 한다.

컴포넌트 별 일반적인 오류 및 처리는 다음과 같다.

- 업로드 오류: 정해진 횟수만큼 재시도 한다.
- 비디오 분할 오류: 클라이언트가 GOP 경계에 따라 비디오를 분할하지 못하는 경우라면 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 한다.
- 트랜스코딩 오류 : 재시도한다.
- 전처리 오류 : DAG 그래프를 재생성 한다.
- DAG 스케줄러 오류 : 작업을 다시 스케줄링 한다.
- 자원 관리자 큐에 장애 발생 : 사본(replica)을 이용한다.
- 작업 서버 장애 : 다른 서버에서 해당 작업을 재시도 한다.
- API 서버 장애 : API 서버는 무상태 서버이므로 신규 요청은 다른 API 서버로 우회될 것이다.
- 메타데이터 캐시 서버 장애 : 데이터는 다중화되어 있으므로 다른 노드에서 데이터를 여전히 가져올 수 있을 것이다. 장애가 난 캐시 서버는 새로운 것으로 교체한다.
- 메타데이터 데이터베이스 서버 장애:
    - 주서버가 죽었다면 부 서버 가운데 하나를 주 서버로 교체한다.
    - 부서버가 죽었다면 다른 부 서버를 통해 읽기 연산을 처리하고 죽은 서버는 새것으로 교체한다.

# 04. 마무리

다음과 같은 사항들은 더 생각해볼 만 하다.

1. API 계층의 규모 확장성 : API 서버는 무상태 서버로 설계하였으므로 수평적 규모 확장이 가능하다.
2. 데이터베이스 계층의 규모 확장성 확보 방안 : 데이터베이스의 다중화와 샤딩 방법
    1. 다중화: 빠른 읽기, 가용성
    2. 샤딩: 확장성
3. 비디오 삭제 정책: 정책을 위반한 비디오는 내려야 한다. 내릴 비디오는 업로드 과정에서 식별해 낼 수도 있지만, 사용자의 신고 절차를 통해 판별할 수도 있다.
