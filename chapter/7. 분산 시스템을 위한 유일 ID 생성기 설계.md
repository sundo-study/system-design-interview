auto increment 속성의 PK로는 분산된 DB 환경에서 유일성을 보장하기 어렵다

## 1단계 문제 이해 및 설계 범위 확정

- ID는 유일
- 숫자로만 구성
- 64비트로 표현될 수 있는 값
- 발급 날짜에 따라 정렬 가능
- 초당 만개의 ID를 생성할 수 있어야 한다.

## 2단계 개략적 설계안 제시 및 동의 구하기

분산 시스템에서 유일성이 보장되는 ID를 만드는 방법

- 다중 마스터 복제
- UUID
- 티켓 서버
- 트위터 스노플레이크 접근법

### 1. 다중 마스터 복제

- 특징
    - DB의 auto increment 기능을 활용하는 것
    - 다만 다음 ID를 구할 때 1만큼 증가시키지 않고 k(현재사용중인 서버 수) 만큼 증가시킨다.
    - 간단하게 적용할 수 있는 방식이고, 한 데이터 센터에서 어느정도 확장도 가능하다
- 단점
    - 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
    - ID의 유일성은 보장되겠지만, 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다
    - 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다

### 2. UUID

- 특징
    - 128비트 UUID를 활용. → 충돌 가능성이 지극히 낮다
    - 서버간의 조율 없이 독립적으로 생산 가능하다
    - 발급 하고 바로 사용하면 되기 때문에 단순하다. 동기화 이슈도 없다. 규모 확장도 용이하다
- 단점
    - 128비트로 용량이 조금 크다 (요구사항에서는 64비트)
    - ID를 시간순으로 정렬할 수 없다.
    - ID에 숫자가 아닌 값이 포함될 수 있다.

### 3. 티켓 서버

- 특징
    - DB의 auto increment를 활용
    - 티켓 서버를 중앙 집중형으로 하나만 사용
- 장점
    - 유일성이 보장되는 오직 숫자로만 구성되는 ID를 쉽게 만들 수 있다.
    - 구현하기 쉽고, 중소 규모 애플리케이션에도 적합하다.
- 단점
    - 티켓 서버가 SPOF가 된다
        - 이를 해결하려고 여러개의 타겟서버를 두면 데이터 동기화 이슈가 생긴다

### 4. 트위터 스노플레이크 접근법 snowflake (요구사항에 가장 적합)

- 특징
    - 분산 환경에서 **전역 유일성과 정렬 가능성**을 동시에 만족하는 64비트 ID를 생성하는 알고리즘
    - 시간 순 정렬 가능 (시간 기반이므로)
    - 64비트 정수 → PK 인덱스 효율 높음
    - DB 부하 감소 → DB가 ID 발급에 관여하지 않음
- 64비트의 구조
    - 사인비트 (1 비트) : 쓰임새가 현재는 없지만 나중을 위해 유보. 음수 양수를 구별하는데 사용할 수 있을 것
    - 타임스탬프 (41비트) : 기원 시각 이후  몇 millisecond 가 경과했는지를 나타내는 값.
    - 데이터 센터 ID (5비트) : 2^5 총 32개의 데이터 센터를 지원할 수 있다
    - 서버 ID (5비트) : 한 데이터 센터당 32개의 서버를 지원할 수 있다.
    - 일련번호  (12비트) : 각 서버에서는 ID를 생성할 때마다 일련번호를 1만큼 증가시키고, 이 값은 1밀리초 기준으로 0으로 초기화 시킨다 (타임스탬프가 바뀌게 된다)

## 3단계 상세 설계

- 데이터 센터 ID나 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 운영 중에는 바뀌지 않는다.
    
    → 잘못 변경하게 되면 충돌 발생할 수 있기 땜에
    
- 타임 스탬프
    - 시간순으로 정렬하기 위한 방법(타임 스탬프는 시간 흐름에 따라 점점 큰 값을 가짐)
    - 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전하여야 한다.
- 일련번호
    - 일련번호는 12비트 이므로 4096개를 만들 수 있으나 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만든 경우에만 0보다 큰 값을 갖게 한다
